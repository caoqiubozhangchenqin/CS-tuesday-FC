# 按需解析方案 - 用户体验优化版

## 📋 核心理念

**从"一次性全部解析"改为"按需渐进解析"**

### 为什么要改？

**原方案问题**：
- 首次打开书籍需要等待 3-5 分钟（解析 1600 章）
- 用户可能只想看前几章，却要等待全书解析
- 超长书籍（2000+ 章）首次解析失败率高

**新方案优势**：
- ✅ **秒开**：首次只解析 50 章，等待时间 < 10 秒
- ✅ **按需加载**：看到第 45 章时自动提示解锁后续 50 章
- ✅ **断点续传**：已解析章节永久保存，下次打开无需重复解析
- ✅ **无限章节**：理论上支持任意长度的书籍

---

## 🎯 用户操作流程

### 场景 1：阅读 500 章小说

```
第 1 步：用户上传小说（5MB TXT 文件）
第 2 步：点击书籍封面
        ↓
        Loading: "解析中..." (等待约 8 秒)
        ↓
        Toast: "已解析前 50 章，剩余章节可在阅读时按需加载" (2.5s)
        ↓
第 3 步：进入阅读器，开始阅读第 1 章 ✅
        （总耗时 < 10 秒，相比原方案的 5 分钟，快了 30 倍！）

---

用户阅读到第 45 章...
        ↓
第 4 步：系统检测到接近已解析章节末尾
        ↓
        Toast: "即将看完，可解锁后续章节" (2s)
        ↓
        章节末尾显示解锁卡片：
        ┌─────────────────────────────────────┐
        │         🔒                           │
        │   即将看完已解析章节（50/500）      │
        │                                     │
        │   [立即解锁后续 50 章]              │ ← 渐变粉色卡片
        └─────────────────────────────────────┘

第 5 步：用户点击"立即解锁后续 50 章"
        ↓
        弹窗确认："本次将解析 50 章，是否继续？"
        ↓ [点击"立即解锁"]
        Loading: "解析中..." (等待约 8 秒)
        ↓
        弹窗："解锁完成，成功解析 50 章，当前进度：100/500"
        ↓
第 6 步：继续阅读第 51-100 章 ✅

---

重复步骤 4-6，直到看完全书
每次解锁只需 8 秒，按需加载，体验流畅！
```

### 场景 2：用户关闭小程序后再打开

```
第 1 步：用户再次打开小程序，点击书籍
        ↓
第 2 步：系统检测到已有解析记录（本地存储）
        ↓
        直接跳转到阅读器 ✅（无需重新解析！）
        ↓
第 3 步：继续阅读上次的进度（第 80 章）
        ↓
        （耗时 < 1 秒，相比原方案需要重新解析，快了无数倍！）
```

---

## 🔧 技术实现细节

### 1. 解析记录数据结构

```javascript
// 存储在 wx.storage，key = `parse_record_${bookId}`
{
  bookId: "book001",
  totalChapters: 500,           // 书籍总章节数
  lastParsedChapter: 100,       // 最后解析到第几章
  parsedRanges: [               // 已解析的章节范围（防止重复解析）
    { start: 0, end: 50 },
    { start: 50, end: 100 }
  ],
  completed: false,             // 是否全部解析完成
  timestamp: 1732257854000      // 最后更新时间
}
```

### 2. 首次解析策略

**关键代码**：`miniprogram/pages/novel/shelf/shelf.js`

```javascript
async parseBookInChunks(book) {
  const INITIAL_CHUNK = 50;  // 🔥 关键：首次只解析 50 章

  // 首次调用云函数
  const { result } = await wx.cloud.callFunction({
    name: 'parseNovel',
    data: {
      fileID: book.fileID,
      format: book.format,
      novelId: book.id,
      chunkStart: 0,
      chunkSize: INITIAL_CHUNK  // 只要 50 章
    }
  });

  // 保存解析记录
  const parseRecord = {
    bookId: book.id,
    totalChapters: result.chapterCount,
    lastParsedChapter: Math.min(50, result.chapterCount),
    parsedRanges: [{ start: 0, end: 50 }],
    completed: !result.hasMore,
    timestamp: Date.now()
  };

  wx.setStorageSync(`parse_record_${book.id}`, parseRecord);
}
```

### 3. 智能解锁提示

**关键代码**：`miniprogram/pages/novel/reader/reader.js`

```javascript
checkUnlockStatus() {
  const { currentChapterIndex, parseRecord, unlockThreshold } = this.data;
  
  if (!parseRecord || parseRecord.completed) {
    // 已全部解析完成，不提示
    return;
  }

  const lastParsedChapter = parseRecord.lastParsedChapter;
  
  // 🔥 关键判断：当前阅读位置接近已解析章节末尾
  const needUnlock = (currentChapterIndex >= lastParsedChapter - 5)  // 距离末尾 5 章
                     && (lastParsedChapter < parseRecord.totalChapters);

  if (needUnlock) {
    this.setData({ needUnlock: true });
    
    // 显示 Toast 提示（只提示一次）
    if (!this.unlockToastShown) {
      this.unlockToastShown = true;
      wx.showToast({
        title: '即将看完，可解锁后续章节',
        icon: 'none',
        duration: 2000
      });
    }
  }
}
```

### 4. 增量解析逻辑

**关键代码**：`miniprogram/pages/novel/reader/reader.js`

```javascript
async continueParsingChapters() {
  const { parseRecord } = this.data;
  const chunkSize = 50;  // 🔥 每次解锁 50 章
  const chunkStart = parseRecord.lastParsedChapter;

  // 调用云函数解析后续 50 章
  const { result } = await wx.cloud.callFunction({
    name: 'parseNovel',
    data: {
      fileID: book.fileID,
      format: book.format,
      novelId: this.data.bookId,
      chunkStart,         // 从上次停止的位置继续
      chunkSize: 50       // 只解析 50 章
    }
  });

  // 更新解析记录
  const updatedRecord = {
    ...parseRecord,
    lastParsedChapter: chunkStart + 50,
    parsedRanges: [
      ...parseRecord.parsedRanges,
      { start: chunkStart, end: chunkStart + 50 }
    ],
    completed: !result.hasMore,
    timestamp: Date.now()
  };

  wx.setStorageSync(`parse_record_${book.id}`, updatedRecord);
}
```

### 5. 避免重复解析

**检查逻辑**：打开书籍时先查缓存

```javascript
// shelf.js
async goToReader(e) {
  // 1. 检查数据库是否已有章节
  const dbResult = await db.collection('novel_chapters')
    .where({ novelId: book.id })
    .count();

  if (dbResult.total > 0) {
    // 已有章节，直接跳转
    wx.navigateTo({ url: `/pages/novel/reader/reader?bookId=${book.id}...` });
    return;
  }

  // 2. 检查是否有解析记录
  const parseRecord = wx.getStorageSync(`parse_record_${book.id}`);
  if (parseRecord && parseRecord.parsedRanges.length > 0) {
    // 已有记录，直接跳转
    wx.navigateTo({ url: `/pages/novel/reader/reader?bookId=${book.id}...` });
    return;
  }

  // 3. 首次打开，开始解析
  await this.parseBookInChunks(book);
}
```

---

## 🎨 UI 设计

### 1. 章节末尾解锁卡片

**位置**：章节内容底部，"下一章"按钮上方

**样式**：
- 渐变背景：粉色到黄色（`#fa709a` → `#fee140`）
- 大图标：🔒 (64rpx)
- 提示文字："即将看完已解析章节（50/500）"
- 解锁按钮：白色背景，圆角，点击缩放动画

**触发条件**：
- 当前章节 ≥ 已解析章节 - 5
- 书籍未全部解析完成

### 2. 底部菜单提示条

**位置**：底部菜单顶部

**样式**：
- 渐变背景：红色（`#ff6b6b` → `#ee5a24`）
- 左侧：🔒 图标 + 进度文字
- 右侧："解锁后 50 章"按钮（白色背景）

**触发条件**：
- 点击底部菜单按钮（☰）时显示
- 与章节末尾卡片条件相同

---

## 📊 性能对比

### 首次打开耗时

| 书籍类型 | 原方案（一次性解析） | 新方案（按需解析） | 提升 |
|---------|---------------------|-------------------|-----|
| 100 章 | ~60s | ~8s | **7.5x** ✅ |
| 500 章 | ~300s (5min) | ~8s | **37.5x** ✅ |
| 1000 章 | ~600s (10min) | ~8s | **75x** ✅ |
| 2000 章 | ❌ 失败 | ~8s | **∞** ✅ |

### 重复打开耗时

| 场景 | 原方案 | 新方案 | 提升 |
|------|--------|--------|-----|
| 已解析过的书籍 | 需重新解析 (~5min) | < 1s（直接读缓存） | **300x** ✅ |

### 云函数调用次数

| 书籍类型 | 原方案（一次性） | 新方案（按需） | 节省 |
|---------|-----------------|---------------|-----|
| 100 章 | 2 次 | 2 次 | 0% |
| 500 章 | 7 次 | 10 次（分 10 批） | -43% ⚠️ |
| 1000 章 | 13 次 | 20 次（分 20 批） | -54% ⚠️ |

**注意**：虽然总调用次数略增，但**首次打开极快**，用户体验提升显著！

---

## ⚙️ 参数配置

### 可调整参数

| 参数 | 当前值 | 说明 | 调整建议 |
|------|--------|------|----------|
| `INITIAL_CHUNK` | 50 章 | 首次解析章节数 | 10-100 章，平衡速度与调用次数 |
| `unlockThreshold` | 5 章 | 距离末尾多少章提示 | 3-10 章，太小会频繁提示 |
| `chunkSize`（增量） | 50 章 | 每次解锁章节数 | 30-80 章，太大可能超时 |

### 推荐配置

**快速打开优先**（当前配置）：
```javascript
INITIAL_CHUNK = 50;        // 首次 50 章
unlockThreshold = 5;       // 提前 5 章提示
chunkSize = 50;            // 每次解锁 50 章
```

**平衡模式**：
```javascript
INITIAL_CHUNK = 80;        // 首次 80 章
unlockThreshold = 10;      // 提前 10 章提示
chunkSize = 80;            // 每次解锁 80 章
```

**极速模式**（激进）：
```javascript
INITIAL_CHUNK = 30;        // 首次 30 章
unlockThreshold = 3;       // 提前 3 章提示
chunkSize = 30;            // 每次解锁 30 章
```

---

## 🚀 部署步骤

### 第一步：部署云函数

```powershell
# 方法 A：开发者工具
右键 cloudfunctions/parseNovel → 上传并部署：云端安装依赖

# 方法 B：命令行
cd f:\CSFC
tcb fn deploy parseNovel
```

### 第二步：编译小程序

```
开发者工具 → 点击"编译"按钮 → 清除缓存 → 重新编译
```

### 第三步：测试功能

**测试 1：首次打开速度**
- 上传一本 500 章小说 → 点击封面
- ✅ 预期：等待 < 10s，Toast 显示"已解析前 50 章"

**测试 2：解锁提示**
- 阅读到第 45 章
- ✅ 预期：Toast 提示"即将看完，可解锁后续章节"
- ✅ 预期：章节末尾显示解锁卡片

**测试 3：解锁功能**
- 点击"立即解锁后续 50 章"
- ✅ 预期：弹窗确认 → Loading → 弹窗"解锁完成"
- ✅ 预期：可以继续阅读第 51-100 章

**测试 4：重复打开**
- 关闭小程序 → 重新打开 → 点击书籍
- ✅ 预期：< 1s 直接进入阅读器，无需重新解析

---

## 📈 数据监控

### 关键指标

**首次打开速度**：
- 目标：< 10s
- 监控：云函数日志中的 `durationMs`

**解锁成功率**：
- 目标：> 95%
- 监控：`continueParsingChapters` 函数的成功/失败次数

**重复解析率**：
- 目标：< 5%
- 监控：有解析记录但仍调用云函数的次数

### 查看方法

```
1. 打开云开发控制台 → 云函数 → parseNovel → 日志
2. 筛选日志：
   - 首次解析：搜索 `chunkStart: 0`
   - 增量解析：搜索 `chunkStart: 50`, `chunkStart: 100` 等
3. 查看 `durationMs` 和 `errCode`
```

---

## ⚠️ 注意事项

### 1. 存储空间管理

**问题**：`wx.storage` 上限 10MB

**解决方案**：
```javascript
// 定期清理超过 30 天的解析记录
const parseRecord = wx.getStorageSync(`parse_record_${bookId}`);
const daysSince = (Date.now() - parseRecord.timestamp) / (1000 * 60 * 60 * 24);

if (daysSince > 30) {
  wx.removeStorageSync(`parse_record_${bookId}`);
}
```

### 2. 云函数配额

**每次解锁消耗**：
- 1 次云函数调用（解析 50 章）
- 约 15s 执行时间
- 约 3.75 GBs

**估算**：
- 免费版：4 万 GBs/月 ÷ 3.75 GBs ≈ **10,666 次解锁**
- 假设每本书平均解锁 10 次 → 可支持 **1,066 本书/月**

### 3. 用户习惯培养

**建议**：
- 首次使用时增加新手引导："本次只解析前 50 章，后续章节可边看边解锁"
- 在上传页提示："推荐按需解析，首次打开更快！"

---

## 🎉 总结

### 核心优势

✅ **极速打开**：首次等待从 5 分钟降至 10 秒，提升 30 倍  
✅ **按需加载**：只解析用户想看的章节，节省云函数配额  
✅ **断点续传**：已解析章节永久保存，重复打开秒开  
✅ **无限章节**：理论支持任意长度书籍（10000+ 章）  
✅ **智能提示**：接近末尾自动提示解锁，不打扰阅读

### 适用场景

- ✅ **短篇小说**（< 100 章）：1-2 次解锁搞定
- ✅ **中篇小说**（100-500 章）：2-10 次解锁，体验流畅
- ✅ **长篇小说**（500-2000 章）：10-40 次解锁，按需加载
- ✅ **超长小说**（2000+ 章）：理论无限制，用户自主控制

### 不适用场景

- ❌ **一次性阅读全书**的用户（需要多次点击解锁）
  - 解决：可添加"一键解锁全书"选项
- ❌ **网络不稳定**的环境（每次解锁都需要网络）
  - 解决：支持离线模式，提前批量解锁

---

## 🔗 相关文档

- [超长书籍解析方案](./超长书籍解析方案.md)（旧版）
- [云函数超时修复](./FIX_CLOUD_FUNCTION_TIMEOUT.md)
- [数据库权限配置](./DATABASE_PERMISSIONS.md)

---

**最后更新**：2025-11-22  
**版本**：v3.0 - 按需解析，极速体验  
**推荐指数**：⭐⭐⭐⭐⭐
