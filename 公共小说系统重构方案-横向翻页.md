# å…¬å…±å°è¯´ç³»ç»Ÿé‡æ„æ–¹æ¡ˆ - æ¨ªå‘ç¿»é¡µ

## ğŸ”‘ æ ¸å¿ƒç‰¹æ€§
- âœ… **å…¬å…±å†…å®¹**ï¼šæ‰€æœ‰ç”¨æˆ·å…±äº«åŒä¸€å¥—å°è¯´èµ„æº
- âœ… **ä¸ªäººè¿›åº¦**ï¼šæ¯ä¸ªç”¨æˆ·æœ‰ç‹¬ç«‹çš„é˜…è¯»è¿›åº¦
- âœ… **æ¨ªå‘ç¿»é¡µ**ï¼šå·¦å³æ»‘åŠ¨é˜…è¯»ï¼Œä¸è§£æç« èŠ‚
- âœ… **ç®€åŒ–æ¶æ„**ï¼šé¿å…è§£æå¤±è´¥é—®é¢˜

---

## ğŸ“Š ç³»ç»Ÿæ¶æ„è°ƒæ•´

### å…³é”®åŒºåˆ«ï¼šå…¬å…± vs ç§æœ‰

| ç‰¹æ€§ | ç§æœ‰ç³»ç»Ÿ | **å…¬å…±ç³»ç»Ÿï¼ˆå½“å‰ï¼‰** |
|------|---------|---------------------|
| å°è¯´ä¸Šä¼ è€… | æ¯ä¸ªç”¨æˆ·ä¸Šä¼ è‡ªå·±çš„ | **ç®¡ç†å‘˜/å®˜æ–¹ä¸Šä¼ ** |
| å­˜å‚¨æ–¹å¼ | æŒ‰ç”¨æˆ·å­˜å‚¨ï¼ˆé‡å¤ï¼‰ | **æ‰€æœ‰ç”¨æˆ·å…±äº«** |
| æƒé™æ§åˆ¶ | `_openid` è¿‡æ»¤ | **å…¬å¼€è¯»å–** |
| å­˜å‚¨æˆæœ¬ | é«˜ï¼ˆé‡å¤å­˜å‚¨ï¼‰ | **ä½ï¼ˆå…±äº«å­˜å‚¨ï¼‰** |
| é˜…è¯»è¿›åº¦ | ä»…è‡ªå·±å¯è§ | **ä»…è‡ªå·±å¯è§** |

---

## ğŸ—„ï¸ æ•°æ®åº“ç»“æ„è®¾è®¡ï¼ˆå…¬å…±ç³»ç»Ÿï¼‰

### 1. novels é›†åˆï¼ˆå…¬å…±å°è¯´åº“ï¼‰

**æƒé™è®¾ç½®**ï¼š
```json
{
  "read": true,           // âœ… æ‰€æœ‰ç”¨æˆ·å¯è¯»
  "write": false          // âŒ ä»…ç®¡ç†å‘˜å¯å†™ï¼ˆé€šè¿‡äº‘å‡½æ•°ï¼‰
}
```

**æ•°æ®ç»“æ„**ï¼š
```javascript
{
  _id: "novel_001",
  title: "è¥¿æ¸¸è®°",
  author: "å´æ‰¿æ©",
  cover: "cloud://xxx/covers/xiyouji.jpg",
  category: "å¤å…¸åè‘—",
  tags: ["ç„å¹»", "ç»å…¸"],
  
  // æ–‡ä»¶ä¿¡æ¯
  fileID: "cloud://xxx/novels/xiyouji.txt",
  fileSize: 1024000,        // å­—èŠ‚
  totalChars: 500000,       // æ€»å­—æ•°
  totalPages: 1000,         // æ€»é¡µæ•°
  charsPerPage: 500,        // æ¯é¡µå­—æ•°ï¼ˆå›ºå®šï¼‰
  
  // ç»Ÿè®¡ä¿¡æ¯
  viewCount: 12580,         // é˜…è¯»æ¬¡æ•°
  favoriteCount: 256,       // æ”¶è—æ¬¡æ•°
  
  // ç®¡ç†ä¿¡æ¯
  uploadTime: 1700654321000,
  updateTime: 1700654321000,
  status: "published",      // published/draft/hidden
  isRecommended: true       // æ˜¯å¦æ¨è
}
```

---

### 2. reading_progress é›†åˆï¼ˆä¸ªäººé˜…è¯»è¿›åº¦ï¼‰

**æƒé™è®¾ç½®**ï¼š
```json
{
  "read": "doc._openid == auth.openid",   // åªèƒ½è¯»è‡ªå·±çš„è¿›åº¦
  "write": "doc._openid == auth.openid"   // åªèƒ½å†™è‡ªå·±çš„è¿›åº¦
}
```

**æ•°æ®ç»“æ„**ï¼š
```javascript
{
  _id: "progress_001",
  _openid: "user_openid_xxx",  // è‡ªåŠ¨ç”Ÿæˆ
  
  // å…³è”å°è¯´ï¼ˆå…¬å…±å°è¯´ IDï¼‰
  novelId: "novel_001",
  novelTitle: "è¥¿æ¸¸è®°",        // å†—ä½™ï¼Œä¾¿äºæŸ¥è¯¢
  
  // é˜…è¯»è¿›åº¦
  currentPage: 58,              // å½“å‰é¡µç 
  charOffset: 29000,            // å­—ç¬¦åç§»é‡ï¼ˆè·¨è®¾å¤‡åŒæ­¥ï¼‰
  totalPages: 1000,             // å°è¯´æ€»é¡µæ•°ï¼ˆå†—ä½™ï¼‰
  progress: 5.8,                // è¿›åº¦ç™¾åˆ†æ¯”
  
  // é˜…è¯»æ—¶é—´ç»Ÿè®¡
  readingTime: 3600,            // ç´¯è®¡é˜…è¯»æ—¶é•¿ï¼ˆç§’ï¼‰
  lastReadTime: 1700654321000,  // æœ€åé˜…è¯»æ—¶é—´
  updateTime: 1700654321000     // æ›´æ–°æ—¶é—´
}
```

---

### 3. user_shelf é›†åˆï¼ˆç”¨æˆ·ä¹¦æ¶ï¼‰

**æƒé™è®¾ç½®**ï¼š
```json
{
  "read": "doc._openid == auth.openid",
  "write": "doc._openid == auth.openid"
}
```

**æ•°æ®ç»“æ„**ï¼š
```javascript
{
  _id: "shelf_001",
  _openid: "user_openid_xxx",
  
  novelId: "novel_001",         // å…³è”å…¬å…±å°è¯´
  addTime: 1700654321000,       // åŠ å…¥ä¹¦æ¶æ—¶é—´
  lastReadTime: 1700654321000,  // æœ€åé˜…è¯»æ—¶é—´
  isFavorite: true,             // æ˜¯å¦æ”¶è—
  
  // å†—ä½™å­—æ®µï¼ˆå‡å°‘è”è¡¨æŸ¥è¯¢ï¼‰
  novelTitle: "è¥¿æ¸¸è®°",
  novelCover: "cloud://xxx/covers/xiyouji.jpg",
  novelAuthor: "å´æ‰¿æ©"
}
```

---

## ğŸ” æƒé™ç®¡ç†æ–¹æ¡ˆ

### æ–¹æ¡ˆ 1ï¼šç®¡ç†å‘˜é€šè¿‡äº‘å‡½æ•°ä¸Šä¼ ï¼ˆæ¨èï¼‰

```javascript
// cloudfunctions/adminUploadNovel/index.js
const cloud = require('wx-server-sdk');
cloud.init();
const db = cloud.database();

exports.main = async (event, context) => {
  const { OPENID } = cloud.getWXContext();
  
  // 1. éªŒè¯ç®¡ç†å‘˜æƒé™
  const adminList = ['admin_openid_1', 'admin_openid_2'];
  if (!adminList.includes(OPENID)) {
    return { success: false, error: 'æ— ç®¡ç†å‘˜æƒé™' };
  }
  
  // 2. ä¸Šä¼ å°è¯´åˆ°äº‘å­˜å‚¨
  const { fileID, title, author, content } = event;
  
  // 3. è®¡ç®—ç»Ÿè®¡ä¿¡æ¯
  const totalChars = content.length;
  const charsPerPage = 500;
  const totalPages = Math.ceil(totalChars / charsPerPage);
  
  // 4. ä¿å­˜åˆ°å…¬å…±å°è¯´åº“
  const result = await db.collection('novels').add({
    data: {
      title,
      author,
      fileID,
      totalChars,
      totalPages,
      charsPerPage,
      viewCount: 0,
      favoriteCount: 0,
      uploadTime: Date.now(),
      status: 'published',
      isRecommended: false
    }
  });
  
  return { success: true, novelId: result._id };
};
```

---

### æ–¹æ¡ˆ 2ï¼šäº‘å¼€å‘æ§åˆ¶å°ç›´æ¥æ“ä½œ

**æ­¥éª¤**ï¼š
1. åœ¨äº‘å¼€å‘æ§åˆ¶å° â†’ äº‘å­˜å‚¨ï¼Œæ‰‹åŠ¨ä¸Šä¼  TXT æ–‡ä»¶
2. è·å– fileIDï¼ˆå¦‚ `cloud://xxx/novels/xiyouji.txt`ï¼‰
3. åœ¨äº‘å¼€å‘æ§åˆ¶å° â†’ æ•°æ®åº“ â†’ novels é›†åˆï¼Œæ‰‹åŠ¨æ·»åŠ è®°å½•
4. è®¾ç½® novels é›†åˆæƒé™ä¸º"æ‰€æœ‰ç”¨æˆ·å¯è¯»ï¼Œä»…ç®¡ç†ç«¯å¯å†™"

---

## ğŸ“± å‰ç«¯åŠŸèƒ½å®ç°

### 1. ä¹¦åŸ/ä¹¦æ¶é¡µé¢

#### ä¹¦åŸï¼ˆæ‰€æœ‰å…¬å…±å°è¯´ï¼‰

**WXML**ï¼š
```xml
<view class="bookstore">
  <!-- æ¨èåŒº -->
  <view class="recommend-section">
    <text class="section-title">ç²¾é€‰æ¨è</text>
    <scroll-view scroll-x>
      <view class="book-item" 
            wx:for="{{recommendBooks}}" 
            wx:key="_id"
            bindtap="openBook" 
            data-id="{{item._id}}">
        <image src="{{item.cover}}" class="book-cover"/>
        <text class="book-title">{{item.title}}</text>
        <text class="book-author">{{item.author}}</text>
        <text class="book-stats">{{item.viewCount}}äººé˜…è¯»</text>
      </view>
    </scroll-view>
  </view>
  
  <!-- åˆ†ç±»åŒº -->
  <view class="category-section">
    <text class="section-title">å¤å…¸åè‘—</text>
    <view class="book-grid">
      <view class="book-item" 
            wx:for="{{classicBooks}}" 
            wx:key="_id"
            bindtap="openBook" 
            data-id="{{item._id}}">
        <!-- ä¹¦ç±å¡ç‰‡ -->
      </view>
    </view>
  </view>
</view>
```

**JS**ï¼š
```javascript
// pages/bookstore/bookstore.js
Page({
  data: {
    recommendBooks: [],
    classicBooks: []
  },

  async onLoad() {
    await this.loadBooks();
  },

  // åŠ è½½å…¬å…±å°è¯´åˆ—è¡¨
  async loadBooks() {
    wx.showLoading({ title: 'åŠ è½½ä¸­...' });
    
    const db = wx.cloud.database();
    
    // æ¨èå°è¯´
    const recommendRes = await db.collection('novels')
      .where({ isRecommended: true, status: 'published' })
      .orderBy('viewCount', 'desc')
      .limit(10)
      .get();
    
    // åˆ†ç±»å°è¯´
    const classicRes = await db.collection('novels')
      .where({ category: 'å¤å…¸åè‘—', status: 'published' })
      .orderBy('viewCount', 'desc')
      .limit(20)
      .get();
    
    this.setData({
      recommendBooks: recommendRes.data,
      classicBooks: classicRes.data
    });
    
    wx.hideLoading();
  },

  // æ‰“å¼€å°è¯´
  openBook(e) {
    const novelId = e.currentTarget.dataset.id;
    wx.navigateTo({
      url: `/pages/reader/reader?novelId=${novelId}`
    });
  }
});
```

---

#### æˆ‘çš„ä¹¦æ¶ï¼ˆç”¨æˆ·æ”¶è—çš„å°è¯´ï¼‰

**JS**ï¼š
```javascript
// pages/shelf/shelf.js
Page({
  data: {
    myBooks: []
  },

  async onShow() {
    await this.loadMyShelf();
  },

  // åŠ è½½æˆ‘çš„ä¹¦æ¶
  async loadMyShelf() {
    const db = wx.cloud.database();
    
    // æŸ¥è¯¢ç”¨æˆ·ä¹¦æ¶ï¼ˆè‡ªåŠ¨è¿‡æ»¤ _openidï¼‰
    const shelfRes = await db.collection('user_shelf')
      .orderBy('lastReadTime', 'desc')
      .get();
    
    // è·å–é˜…è¯»è¿›åº¦
    const novelIds = shelfRes.data.map(item => item.novelId);
    const progressRes = await db.collection('reading_progress')
      .where({
        novelId: db.command.in(novelIds)
      })
      .get();
    
    // åˆå¹¶æ•°æ®
    const progressMap = {};
    progressRes.data.forEach(p => {
      progressMap[p.novelId] = p;
    });
    
    const myBooks = shelfRes.data.map(book => ({
      ...book,
      progress: progressMap[book.novelId]?.progress || 0,
      currentPage: progressMap[book.novelId]?.currentPage || 0
    }));
    
    this.setData({ myBooks });
  },

  // åŠ å…¥ä¹¦æ¶
  async addToShelf(novelId, novelData) {
    const db = wx.cloud.database();
    
    // æ£€æŸ¥æ˜¯å¦å·²åœ¨ä¹¦æ¶
    const exist = await db.collection('user_shelf')
      .where({ novelId })
      .get();
    
    if (exist.data.length > 0) {
      wx.showToast({ title: 'å·²åœ¨ä¹¦æ¶ä¸­', icon: 'none' });
      return;
    }
    
    // æ·»åŠ åˆ°ä¹¦æ¶
    await db.collection('user_shelf').add({
      data: {
        novelId,
        novelTitle: novelData.title,
        novelCover: novelData.cover,
        novelAuthor: novelData.author,
        addTime: Date.now(),
        lastReadTime: Date.now(),
        isFavorite: true
      }
    });
    
    // æ›´æ–°å°è¯´æ”¶è—æ•°
    await db.collection('novels').doc(novelId).update({
      data: {
        favoriteCount: db.command.inc(1)
      }
    });
    
    wx.showToast({ title: 'å·²åŠ å…¥ä¹¦æ¶', icon: 'success' });
  }
});
```

---

### 2. é˜…è¯»å™¨é¡µé¢ï¼ˆæ ¸å¿ƒï¼‰

**JSï¼ˆå…³é”®é€»è¾‘ï¼‰**ï¼š
```javascript
// pages/reader/reader.js
Page({
  data: {
    novelId: '',
    novelInfo: null,        // å°è¯´å…ƒä¿¡æ¯ï¼ˆå…¬å…±ï¼‰
    currentPage: 0,
    totalPages: 0,
    visiblePages: [],       // å½“å‰å¯è§çš„ 3 é¡µ
    charsPerPage: 500,
    fullContent: null,      // å®Œæ•´æ–‡æœ¬ï¼ˆåˆ†æ®µåŠ è½½ï¼‰
    currentSegment: 0,      // å½“å‰åŠ è½½çš„åˆ†æ®µ
    segmentCache: {}        // åˆ†æ®µç¼“å­˜
  },

  async onLoad(options) {
    const { novelId } = options;
    this.setData({ novelId });
    
    // 1. åŠ è½½å°è¯´å…ƒä¿¡æ¯ï¼ˆå…¬å…±æ•°æ®ï¼‰
    await this.loadNovelInfo();
    
    // 2. æ¢å¤é˜…è¯»è¿›åº¦ï¼ˆä¸ªäººæ•°æ®ï¼‰
    await this.loadProgress();
    
    // 3. åŠ è½½å†…å®¹ï¼ˆé¦–æ®µï¼‰
    await this.loadContent();
    
    // 4. æ›´æ–°é˜…è¯»ç»Ÿè®¡
    this.updateViewCount();
    
    // 5. è‡ªåŠ¨åŠ å…¥ä¹¦æ¶
    this.autoAddToShelf();
  },

  // åŠ è½½å°è¯´å…ƒä¿¡æ¯ï¼ˆå…¬å…±ï¼‰
  async loadNovelInfo() {
    const db = wx.cloud.database();
    const res = await db.collection('novels')
      .doc(this.data.novelId)
      .get();
    
    if (!res.data) {
      wx.showToast({ title: 'å°è¯´ä¸å­˜åœ¨', icon: 'none' });
      setTimeout(() => wx.navigateBack(), 1500);
      return;
    }
    
    this.setData({
      novelInfo: res.data,
      totalPages: res.data.totalPages,
      charsPerPage: res.data.charsPerPage
    });
  },

  // åŠ è½½é˜…è¯»è¿›åº¦ï¼ˆä¸ªäººï¼‰
  async loadProgress() {
    const db = wx.cloud.database();
    const res = await db.collection('reading_progress')
      .where({ novelId: this.data.novelId })
      .get();
    
    if (res.data.length > 0) {
      const progress = res.data[0];
      this.setData({
        currentPage: progress.currentPage || 0
      });
      
      console.log(`æ¢å¤è¿›åº¦ï¼šç¬¬ ${progress.currentPage + 1} é¡µ`);
    }
  },

  // åŠ è½½å†…å®¹ï¼ˆåˆ†æ®µç­–ç•¥ï¼‰
  async loadContent() {
    const segmentSize = 100; // æ¯æ®µ 100 é¡µ
    const currentPage = this.data.currentPage;
    const segmentIndex = Math.floor(currentPage / segmentSize);
    
    // æ£€æŸ¥ç¼“å­˜
    if (this.data.segmentCache[segmentIndex]) {
      this.renderPages(currentPage);
      return;
    }
    
    // ä¸‹è½½æ–‡ä»¶åˆ†æ®µ
    wx.showLoading({ title: 'åŠ è½½ä¸­...' });
    
    const { fileID, charsPerPage } = this.data.novelInfo;
    const startChar = segmentIndex * segmentSize * charsPerPage;
    const endChar = startChar + segmentSize * charsPerPage;
    
    // æ–¹æ¡ˆ Aï¼šä¸‹è½½å®Œæ•´æ–‡ä»¶åæˆªå–ï¼ˆç®€å•ä½†æ…¢ï¼‰
    const res = await wx.cloud.downloadFile({ fileID });
    const fs = wx.getFileSystemManager();
    const content = fs.readFileSync(res.tempFilePath, 'utf8');
    const segmentContent = content.substring(startChar, endChar);
    
    // ç¼“å­˜è¯¥åˆ†æ®µ
    this.data.segmentCache[segmentIndex] = segmentContent;
    
    wx.hideLoading();
    this.renderPages(currentPage);
  },

  // æ¸²æŸ“å¯è§é¡µï¼ˆå½“å‰é¡µ Â± 1ï¼‰
  renderPages(centerPage) {
    const pages = [];
    const segmentIndex = Math.floor(centerPage / 100);
    const segmentContent = this.data.segmentCache[segmentIndex];
    const charsPerPage = this.data.charsPerPage;
    
    for (let i = centerPage - 1; i <= centerPage + 1; i++) {
      if (i >= 0 && i < this.data.totalPages) {
        const localPageIndex = i % 100; // åœ¨åˆ†æ®µä¸­çš„ç´¢å¼•
        const start = localPageIndex * charsPerPage;
        const end = start + charsPerPage;
        const content = segmentContent.substring(start, end);
        
        pages.push({ index: i, content });
      }
    }
    
    this.setData({ visiblePages: pages });
  },

  // ç¿»é¡µäº‹ä»¶
  onPageChange(e) {
    const newPage = e.detail.current;
    const oldPage = this.data.currentPage;
    
    // æ›´æ–°å½“å‰é¡µ
    this.setData({ currentPage: newPage });
    
    // é¢„åŠ è½½ç›¸é‚»åˆ†æ®µ
    const newSegment = Math.floor(newPage / 100);
    const oldSegment = Math.floor(oldPage / 100);
    if (newSegment !== oldSegment) {
      this.loadContent();
    } else {
      this.renderPages(newPage);
    }
    
    // é˜²æŠ–ä¿å­˜è¿›åº¦
    clearTimeout(this.saveTimer);
    this.saveTimer = setTimeout(() => {
      this.saveProgress();
    }, 1000);
  },

  // ä¿å­˜é˜…è¯»è¿›åº¦ï¼ˆä¸ªäººï¼‰
  async saveProgress() {
    const db = wx.cloud.database();
    const { novelId, currentPage, totalPages, charsPerPage } = this.data;
    
    const progressData = {
      novelId,
      novelTitle: this.data.novelInfo.title,
      currentPage,
      charOffset: currentPage * charsPerPage,
      totalPages,
      progress: ((currentPage / totalPages) * 100).toFixed(2),
      lastReadTime: Date.now(),
      updateTime: Date.now()
    };
    
    // æŸ¥è¯¢æ˜¯å¦å·²æœ‰è¿›åº¦
    const exist = await db.collection('reading_progress')
      .where({ novelId })
      .get();
    
    if (exist.data.length > 0) {
      // æ›´æ–°
      await db.collection('reading_progress')
        .doc(exist.data[0]._id)
        .update({ data: progressData });
    } else {
      // æ–°å¢ï¼ˆ_openid è‡ªåŠ¨æ·»åŠ ï¼‰
      await db.collection('reading_progress')
        .add({ data: progressData });
    }
    
    console.log('è¿›åº¦å·²ä¿å­˜');
  },

  // æ›´æ–°é˜…è¯»ç»Ÿè®¡ï¼ˆå…¬å…±æ•°æ®ï¼‰
  async updateViewCount() {
    const db = wx.cloud.database();
    await db.collection('novels')
      .doc(this.data.novelId)
      .update({
        data: {
          viewCount: db.command.inc(1)
        }
      });
  },

  // è‡ªåŠ¨åŠ å…¥ä¹¦æ¶
  async autoAddToShelf() {
    const db = wx.cloud.database();
    const { novelId, novelInfo } = this.data;
    
    const exist = await db.collection('user_shelf')
      .where({ novelId })
      .get();
    
    if (exist.data.length === 0) {
      await db.collection('user_shelf').add({
        data: {
          novelId,
          novelTitle: novelInfo.title,
          novelCover: novelInfo.cover,
          novelAuthor: novelInfo.author,
          addTime: Date.now(),
          lastReadTime: Date.now(),
          isFavorite: false
        }
      });
    } else {
      // æ›´æ–°æœ€åé˜…è¯»æ—¶é—´
      await db.collection('user_shelf')
        .doc(exist.data[0]._id)
        .update({
          data: { lastReadTime: Date.now() }
        });
    }
  }
});
```

---

## ğŸ”’ å®‰å…¨æ€§è€ƒè™‘

### 1. é˜²æ­¢æ¶æ„ä¸Šä¼ 

**é—®é¢˜**ï¼šæ™®é€šç”¨æˆ·ä¸èƒ½ä¸Šä¼ å°è¯´ï¼Œåªæœ‰ç®¡ç†å‘˜å¯ä»¥

**è§£å†³æ–¹æ¡ˆ**ï¼š
```javascript
// äº‘å‡½æ•°ä¸­éªŒè¯ç®¡ç†å‘˜
const adminList = ['admin_openid_1', 'admin_openid_2'];
if (!adminList.includes(OPENID)) {
  return { success: false, error: 'æ— æƒé™' };
}
```

### 2. é˜²æ­¢æ•°æ®ç¯¡æ”¹

**novels é›†åˆæƒé™**ï¼š
```json
{
  "read": true,
  "write": "auth.openid == 'admin_openid'"  // åªæœ‰ç®¡ç†å‘˜å¯å†™
}
```

### 3. é˜²æ­¢è¿›åº¦ä¼ªé€ 

**reading_progress æƒé™**ï¼š
```json
{
  "read": "doc._openid == auth.openid",
  "write": "doc._openid == auth.openid"
}
```
è‡ªåŠ¨è¿‡æ»¤ï¼Œç”¨æˆ·åªèƒ½ä¿®æ”¹è‡ªå·±çš„è¿›åº¦

---

## ğŸ’° æˆæœ¬ä¼˜åŒ–

### å…¬å…±ç³»ç»Ÿ vs ç§æœ‰ç³»ç»Ÿæˆæœ¬å¯¹æ¯”

å‡è®¾ 100 ä¸ªç”¨æˆ·ï¼Œæ¯äººé˜…è¯» 10 æœ¬ä¹¦ï¼š

| é¡¹ç›® | ç§æœ‰ç³»ç»Ÿ | å…¬å…±ç³»ç»Ÿ | èŠ‚çœ |
|------|---------|---------|------|
| **å°è¯´æ–‡ä»¶å­˜å‚¨** | 100äºº Ã— 10ä¹¦ Ã— 10MB = 10GB | 10ä¹¦ Ã— 10MB = 100MB | **99%** â†“ |
| **ç« èŠ‚æ•°æ®** | 100äºº Ã— 10ä¹¦ Ã— 5MB = 5GB | 0 | **100%** â†“ |
| **è¿›åº¦æ•°æ®** | 100äºº Ã— 10ä¹¦ Ã— 1KB = 1MB | 100äºº Ã— 10ä¹¦ Ã— 1KB = 1MB | 0 |
| **æ€»æˆæœ¬** | ~15GB | ~101MB | **99.3%** â†“ |

**ç»“è®º**ï¼šå…¬å…±ç³»ç»Ÿæå¤§é™ä½å­˜å‚¨æˆæœ¬ï¼

---

## ğŸ“ˆ åŠŸèƒ½æ‰©å±•

### 1. è¯„è®ºç³»ç»Ÿ
```javascript
// book_comments é›†åˆ
{
  _openid: "user_openid",
  novelId: "novel_001",
  content: "å¥½çœ‹ï¼",
  rating: 5,
  createTime: 1700654321000
}
```

### 2. æ’è¡Œæ¦œ
```javascript
// çƒ­é—¨å°è¯´ï¼ˆæŒ‰é˜…è¯»é‡ï¼‰
db.collection('novels')
  .orderBy('viewCount', 'desc')
  .limit(10)
  .get();

// æœ€æ–°ä¸Šæ¶
db.collection('novels')
  .orderBy('uploadTime', 'desc')
  .limit(10)
  .get();
```

### 3. æœç´¢åŠŸèƒ½
```javascript
// æ¨¡ç³Šæœç´¢
db.collection('novels')
  .where({
    title: db.RegExp({
      regexp: 'è¥¿æ¸¸',
      options: 'i'
    })
  })
  .get();
```

---

## ğŸš€ éƒ¨ç½²æ­¥éª¤

### é˜¶æ®µ 1ï¼šæ•°æ®åº“å‡†å¤‡
1. åˆ›å»º `novels` é›†åˆï¼Œæƒé™è®¾ç½®ä¸º"æ‰€æœ‰ç”¨æˆ·å¯è¯»"
2. åˆ›å»º `reading_progress` é›†åˆï¼Œæƒé™è®¾ç½®ä¸º"ä»…åˆ›å»ºè€…å¯è¯»å†™"
3. åˆ›å»º `user_shelf` é›†åˆï¼Œæƒé™è®¾ç½®ä¸º"ä»…åˆ›å»ºè€…å¯è¯»å†™"

### é˜¶æ®µ 2ï¼šä¸Šä¼ åˆå§‹å°è¯´
1. å‡†å¤‡å‡ æœ¬æµ‹è¯•å°è¯´ï¼ˆTXT æ ¼å¼ï¼‰
2. ä¸Šä¼ åˆ°äº‘å­˜å‚¨ `novels/` ç›®å½•
3. åœ¨ `novels` é›†åˆä¸­æ·»åŠ å…ƒæ•°æ®è®°å½•

### é˜¶æ®µ 3ï¼šå¼€å‘å‰ç«¯
1. ä¹¦åŸé¡µé¢ï¼ˆå±•ç¤ºå…¬å…±å°è¯´ï¼‰
2. é˜…è¯»å™¨é¡µé¢ï¼ˆæ¨ªå‘ç¿»é¡µï¼‰
3. æˆ‘çš„ä¹¦æ¶é¡µé¢ï¼ˆä¸ªäººæ”¶è—ï¼‰

### é˜¶æ®µ 4ï¼šæµ‹è¯•å’Œä¼˜åŒ–
1. æµ‹è¯•å¤šç”¨æˆ·åŒæ—¶é˜…è¯»
2. æµ‹è¯•è¿›åº¦åŒæ­¥
3. æ€§èƒ½ä¼˜åŒ–ï¼ˆç¼“å­˜ã€æ‡’åŠ è½½ï¼‰

---

## ğŸ“ å…³é”®å·®å¼‚æ€»ç»“

### å…¬å…±ç³»ç»Ÿç‰¹ç‚¹
- âœ… **å…±äº«å†…å®¹**ï¼šæ‰€æœ‰ç”¨æˆ·çœ‹åˆ°ç›¸åŒçš„å°è¯´åº“
- âœ… **ä¸ªäººè¿›åº¦**ï¼šæ¯ä¸ªç”¨æˆ·ç‹¬ç«‹çš„é˜…è¯»è¿›åº¦
- âœ… **æƒé™åˆ†ç¦»**ï¼šå°è¯´å…¬å¼€è¯»ï¼Œè¿›åº¦ç§æœ‰å†™
- âœ… **æˆæœ¬æä½**ï¼šä¸é‡å¤å­˜å‚¨å°è¯´æ–‡ä»¶
- âœ… **æ˜“äºç®¡ç†**ï¼šç»Ÿä¸€ç®¡ç†å°è¯´åº“

### éœ€è¦æ³¨æ„
- âš ï¸ ç®¡ç†å‘˜ä¸Šä¼ å°è¯´éœ€è¦åå°å·¥å…·æˆ–äº‘å‡½æ•°
- âš ï¸ å°è¯´æ›´æ–°/åˆ é™¤ä¼šå½±å“æ‰€æœ‰ç”¨æˆ·
- âš ï¸ éœ€è¦è€ƒè™‘ç‰ˆæƒé—®é¢˜ï¼ˆå»ºè®®ä½¿ç”¨å…¬ç‰ˆä¹¦ç±ï¼‰

---

**é€‚ç”¨åœºæ™¯**ï¼š
- âœ… å…¬ç‰ˆå°è¯´é˜…è¯»å¹³å°
- âœ… ä¼ä¸šå†…éƒ¨æ–‡æ¡£é˜…è¯»
- âœ… æ•™è‚²è¯¾ç¨‹èµ„æ–™é˜…è¯»
- âœ… ç¤¾åŒºå…±äº«å›¾ä¹¦é¦†

**ä¸é€‚ç”¨åœºæ™¯**ï¼š
- âŒ ç”¨æˆ·ä¸Šä¼ ç§äººå°è¯´
- âŒ éœ€è¦ DRM ç‰ˆæƒä¿æŠ¤
- âŒ ä¸ªæ€§åŒ–ç¼–è¾‘å°è¯´å†…å®¹

---

**æ›´æ–°æ—¶é—´**: 2025-01-23  
**ç³»ç»Ÿç±»å‹**: å…¬å…±å†…å®¹ + ä¸ªäººè¿›åº¦  
**é¢„è®¡å¼€å‘å‘¨æœŸ**: 5-7 å¤©
